'''
Created on 20.08.2016

@author: Stefan Richthofer
'''

import sys, typing, inspect, types, re, os, imp, subprocess
import warnings, tempfile, hashlib, atexit
from typing import Tuple, List, Union, Any

stub_open_mode = "U"
stub_descr = (".pyi", stub_open_mode, imp.PY_SOURCE)

python3_5_executable = "python3" # Must be >= 3.5.0

check_override_at_runtime = False
check_override_at_class_definition_time = True

not_type_checked = set()
stub_modules = {}

# Search-path for stubfiles.
stub_path = []

# Directory to collect generated stubs. If None, tempfile.gettempdir() is used.
stub_gen_dir = None

class TypeCheckError(Exception): pass
class TypeCheckSpecificationError(Exception): pass
class InputTypeError(TypeCheckError): pass
class ReturnTypeError(TypeCheckError): pass
class OverrideError(TypeCheckError): pass

def _check_python3_5_version():
	try:
		ver = subprocess.check_output([python3_5_executable, "--version"])
		ver = ver[:-1].split(' ')[-1].split('.')
		return (int(ver[0]) >= 3 and int(ver[1]) >= 5)
	except Exception:
		return False

def _create_Python_2_stub(module_filepath, out_file = None):
	if out_file is None:
		out_file = _gen_stub2_filename(module_filepath)
	dirname = os.path.dirname(__file__)
	sep = __file__[len(dirname)]
	conv_script = dirname+sep+'stubfile_2_converter.py'
	# env = {} is required to prevent pydev from crashing
	subprocess.call([python3_5_executable, conv_script, '-s', '-o', out_file, module_filepath], env = {})

def _get_stub_module(module_filepath):
	module_name = os.path.basename(module_filepath)
	try:
		with open(module_filepath, stub_open_mode) as module_file:
			with warnings.catch_warnings():
				warnings.simplefilter("ignore")
				stub_module = imp.load_module(module_name, module_file, module_filepath, stub_descr)
				return stub_module
	except SyntaxError:
		return None

def _md5(fname):
	m = hashlib.md5()
	with open(fname, "rb") as f:
		for chunk in iter(lambda: f.read(4096), b""):
			m.update(chunk)
	return m.hexdigest()

def _full_module_file_name_nosuffix(module_name):
	module = sys.modules[module_name]
	bn = os.path.basename(module.__file__).rpartition('.')[0]
	if not (module.__package__ is None or module.__package__ == ''):
		return module.__package__.replace('.', os.sep)+os.sep+bn
	else:
		return bn

def _find_files(file_name, search_paths):
	res = []
	if os.path.isfile(file_name):
		res.append(file_name)
	if search_paths is None:
		return res
	for path in search_paths:
		if not path.endswith(os.sep):
			file_path = path+os.sep+file_name
		else:
			file_path = path+file_name
		if os.path.isfile(file_path):
			res.append(file_path)
	return res

def _find_stub_files(module_name):
	full_name = _full_module_file_name_nosuffix(module_name)
	file_name = full_name+'.pyi'
	file_name2 = _plain_stub2_filename(file_name)
	return _find_files(file_name, stub_path), _find_files(file_name2, stub_path)

def _plain_stub2_filename(stub_file):
	return stub_file.rpartition('.')[0]+'.pyi2'

def _gen_stub2_filename(stub_file, base_module):
	if os.path.isfile(stub_file):
		bn = os.path.basename(stub_file).rpartition('.')[0]
		if stub_gen_dir is None:
			checksum = _md5(stub_file)
			return tempfile.gettempdir()+os.sep+bn+'__'+checksum+'.pyi2'
		else:
			pck = '' if base_module.__package__ is None else \
					base_module.__package__.replace('.', os.sep)+os.sep
			return os.path.abspath(stub_gen_dir)+os.sep+pck+bn+'.pyi2'
	else:
		# If there is no original file, no generated file(name) can be created:
		return None

def _check_py2_stubmodule(pyi_file, pyi2_module):
	if pyi2_module.__doc__ is None:
		# File was hand-crafted.
		return True
	lines = pyi2_module.__doc__.split('\n')
	if len(lines) < 5 or lines[4] != "This file was generated by pytypes. Do not edit directly.":
		# File was hand-crafted.
		return True
	if (not pyi_file is None) and os.path.normpath(pyi_file) != os.path.normpath(lines[2]):
		# File wasn't generated from the source we thought it was.
		return False
	in_file = lines[2] if pyi_file is None else pyi_file
	if os.path.isfile(in_file):
		return lines[3].endswith(_md5(in_file))
	else:
		return False

def get_stub_module(func):
	module = sys.modules[func.__module__]
	assert(inspect.ismodule(module))
	m_name = module.__name__
	
	if m_name.endswith('.pyi') or m_name.endswith('.pyi2'):
		return None
	m_key = m_name+str(id(module))
	if m_key in stub_modules:
		return stub_modules[m_key]
	module_filepath = module.__file__.rpartition('.')[0]+'.pyi'
	stub_files = _find_stub_files(m_name)
	module_filepath2_gen = _gen_stub2_filename(module_filepath, module)
	if not (sys.version_info.major >= 3 and sys.version_info.minor >= 5):
		# Python version < 3.5, so try to use a Python 2-style stub.
		# First look for a not-generated one:
		for module_filepath2_plain in stub_files[1]:
			stub_module = _get_stub_module(module_filepath2_plain)
			if not stub_module is None:
				stub_modules[m_key] = stub_module
				return stub_module
		# Now for a previously generated one:
		if (not module_filepath2_gen is None) and os.path.isfile(module_filepath2_gen):
			stub_module = _get_stub_module(module_filepath2_gen)
			if not stub_module is None:
				# A generated module might be outdated:
				# We only check this and attempt to re-create outdated stub-files
				# for files found under stub_gen_dir.
				for module_filepath in stub_files[0]:
					if _check_py2_stubmodule(module_filepath, stub_module):
						stub_modules[m_key] = stub_module
						return stub_module
				# Otherwise we let the code below re-create the module.
				# Note that we cannot be in tmp-dir mode, since the pyi2-file
				# would not have been kept in that case.
	# Python >= 3.5 or no Python 2-style stub available, so try original stub:
	# Simply try to load one of the stubs in search-folders:
	for module_filepath in stub_files[0]:
		stub_module = _get_stub_module(module_filepath)
		if not stub_module is None:
			stub_modules[m_key] = stub_module
			return stub_module
	# Try Python2-style stubs in search-folders, even if running Python 3:
	for module_filepath in stub_files[1]:
		stub_module = _get_stub_module(module_filepath)
		if not stub_module is None:
			stub_modules[m_key] = stub_module
			return stub_module
	# Finally try to convert a Python3 stub to Python2-style:
	if not (sys.version_info.major >= 3 and sys.version_info.minor >= 5):
		# Most likely the module-stub could not be loaded due to Python 3.5-syntax
		if _check_python3_5_version():
			for module_filepath in stub_files[0]:
				# We try to use a local Python 3 version to generate a Python 2-style stub:
				_create_Python_2_stub(module_filepath, module_filepath2_gen)
				if os.path.isfile(module_filepath2_gen):
					stub_module = _get_stub_module(module_filepath2_gen)
					if stub_gen_dir is None:
						atexit.register(os.remove, module_filepath2_gen)
						atexit.register(os.remove, module_filepath2_gen+'c')
						# Todo: Clean up other potential by-products
					if not stub_module is None:
						stub_modules[m_key] = stub_module
						return stub_module
				#else:
				# Todo: Raise warning in verbose mode.
				#	print("Stubfile creation failed: "+module_filepath2_gen)
	# No stub-file available
	stub_modules[m_key] = None
	return None

def _striptrailingcomment(s):
	pos = s.find('#')
	if pos > -1:
		return s[:pos].strip()
	else:
		return s.strip()

def _parse_typecomment_oneline(line):
	commStart = line.find('#')
	tp_delim = "type"
	if commStart > -1 and len(line) > commStart+1:
		comment = line[commStart+1:].strip()
		if (comment.startswith(tp_delim) and len(comment) > len(tp_delim)+1):
			comment = comment[len(tp_delim):].strip()
			if (comment.startswith(':')):
				comment = comment[1:].strip()
				if len(comment) > 0:
					return comment
	return None

# def _get_typestring(obj):
# 	srclines = inspect.getsourcelines(obj)[0]
# 	funcstart = 0
# 	startInit = False
# 	for line in srclines:
# 		ln = _striptrailingcomment(line)
# 		if ln.startswith("def "):
# 			startInit = True
# 		if startInit and ln.endswith(":"):
# 			if (ln[:-1].strip().endswith(")")):
# 				break
# 		funcstart += 1
# 	if len(srclines) <= funcstart:
# 		return None
# 	res = _parse_typecomment_oneline(srclines[funcstart])
# 	if not res is None:
# 		return res
# 	if len(srclines) > funcstart+1 and srclines[funcstart+1].strip()[0] == '#':
# 		#return srclines[funcstart+1][srclines[funcstart+1].find(tp_delim)+len(tp_delim):].strip()
# 		return _parse_typecomment_oneline(srclines[funcstart+1])
# 	else:
# 		return None

def _get_typestrings(obj, slf):
	srclines = inspect.getsourcelines(obj)[0]
	funcstart = 0
	startInit = False
	result = []
	for line in srclines:
		ln = _striptrailingcomment(line)
		if len(ln) > 0:
			if ln.startswith("def "):
				startInit = True
			if startInit:
				if ln.endswith(":"):
					if ln[:-1].strip().endswith(")") or ln.find('->') != -1:
						break
				elif not ln[-1] == '(':
					result.append(_parse_typecomment_oneline(line))
		funcstart += 1
	if len(srclines) <= funcstart:
		return None
	res = _parse_typecomment_oneline(srclines[funcstart])
	if not res is None:
		return res, result[1:] if slf else result
	if len(srclines) > funcstart+1 and srclines[funcstart+1].strip()[0] == '#':
		res= _parse_typecomment_oneline(srclines[funcstart+1]), result[1:] if slf else result
		return res
	else:
		return None, result[1:] if slf else result

def _isargsellipsis(argStr):
	return argStr[1:-1].strip() == '...'

def _funcsigtypesfromstring(typestring, argTypes = None, globals = globals(), selfType = None):
	splt = typestring.find('->')
	if splt == -1:
		return None
	argString = typestring[:splt].strip()
	if _isargsellipsis(argString):
# 		useEllipsis = True
		argString = ''.join(('(', ', '.join(['Any' if x is None else x for x in argTypes]), ')'))
# 	else:
# 		useEllipsis = False
	resString = typestring[splt+2:].strip()
	if selfType is None:
		tpl = Tuple[eval(argString, globals)]
	else:
		argTypes = [selfType]
		argTypes += eval(argString, globals)
		tpl =  Tuple[tuple(argTypes)]
# 	if useEllipsis:
# 		tpl.__tuple_use_ellipsis__ = True
	return tpl, eval(resString, globals)

def deep_type(obj):
	res = type(obj)
	if res == tuple:
		res = Tuple[tuple(deep_type(t) for t in obj)]
	elif res == list:
		res = List[Union[tuple(deep_type(t) for t in obj)]]
	return res

def _methargtype(obj):
	assert(type(obj) == tuple)
	return Tuple[tuple(deep_type(t) for t in obj[1:])]

def as_stub_func_if_any(func0):
	# Check for stubfile
	module = get_stub_module(func0)
	if not module is None and hasattr(module, func0.__name__):
		return getattr(module, func0.__name__)
	else:
		return func0

def has_type_hints(func0):
	func = as_stub_func_if_any(_actualfunc(func0))
	tpHints = typing.get_type_hints(func)
	tpStr = _get_typestrings(func, False)
	return not ((tpStr is None or tpStr[0] is None) and (tpHints is None or not tpHints))

def _funcsigtypes(func0, slf):
	# Check for stubfile
	func = as_stub_func_if_any(_actualfunc(func0))

	tpHints = typing.get_type_hints(func)
	tpStr = _get_typestrings(func, slf)
	if (tpStr is None or tpStr[0] is None) and (tpHints is None or not tpHints):
		# Maybe raise warning here
		return Any, Any
	if not (tpStr is None or tpStr[0] is None) and tpStr[0].find('...') != 0:
		numArgs = len(getargspecs(func).args) - 1 if slf else 0
		while len(tpStr[1]) < numArgs:
			tpStr[1].append(None)
	globs = sys.modules[func.__module__].__dict__
	if not tpHints is None and tpHints:
		# We're running Python 3
		argNames = inspect.getfullargspec(func).args
		if slf:
			argNames = argNames[1:]
		resType = (Tuple[tuple((tpHints[t] if t in tpHints else Any) for t in argNames)],
				tpHints['return'])
		if not (tpStr is None or tpStr[0] is None):
			resType2 = _funcsigtypesfromstring(*tpStr, globals = globs)
			if resType != resType2:
				raise TypeCheckSpecificationError("%s.%s declares incompatible types:\n"
					% (func.__module__, func.__name__)
					+ "Via hints:   %s\nVia comment: %s"
					% (_type_str(resType), _type_str(resType2)))
		return resType
	res = _funcsigtypesfromstring(*tpStr, globals = globs)
	return res

def getargspecs(func):
	if hasattr(func, "ch_func"):
		return getargspecs(func.ch_func)
	elif hasattr(func, "ov_func"):
		return getargspecs(func.ov_func)
	if hasattr(inspect, 'getfullargspec'):
		return inspect.getfullargspec(func) # Python 3
	else:
		return inspect.getargspec(func)

def _check_override_types(method, meth_types, class_name, base_method, base_class_name):
	base_types = _funcsigtypes(base_method, True)
	if has_type_hints(base_method):
		if not issubclass(base_types[0], meth_types[0]):
			raise OverrideError("%s.%s.%s cannot override %s.%s.%s.\n"
					% (method.__module__, class_name, method.__name__, base_method.__module__, base_class_name, base_method.__name__)
					+ "Incompatible argument types: %s is not a subtype of %s."
					% (_type_str(base_types[0]), _type_str(meth_types[0])))
		if not issubclass(meth_types[1], base_types[1]):
			raise OverrideError("%s.%s.%s cannot override %s.%s.%s.\n"
					% (method.__module__, class_name, method.__name__, base_method.__module__, base_class_name, base_method.__name__)
					+ "Incompatible result types: %s is not a subtype of %s."
					% (_type_str(meth_types[1]), _type_str(base_types[1])))

def _check_override_argspecs(method, argSpecs, class_name, base_method, base_class_name):
	ovargs = getargspecs(base_method)
	d1 = 0 if ovargs.defaults is None else len(ovargs.defaults)
	d2 = 0 if argSpecs.defaults is None else len(argSpecs.defaults)
	if len(ovargs.args)-d1 < len(argSpecs.args)-d2 or len(ovargs.args) > len(argSpecs.args):
		raise OverrideError("%s.%s.%s cannot override %s.%s.%s:\n"
				% (method.__module__, class_name, method.__name__, base_method.__module__, base_method.__name__, base_class_name)
				+ "Mismatching argument count. Base-method: %i+%i   submethod: %i+%i"
				% (len(ovargs.args)-d1, d1, len(argSpecs.args)-d2, d2))

def _no_base_method_error(method):
	return OverrideError("%s in %s does not override any other method.\n"
					% (method.__name__, method.__module__))

def _function_instead_of_method_error(method):
	return OverrideError("@override was applied to a function, not a method: %s.%s.\n"
					% (method.__module__, method.__name__))

def override(func):
	if check_override_at_class_definition_time:
		# We need some trickery here, because details of the class are not yet available
		# as it is just getting defined. Luckily we can get base-classes via inspect.stack():

		stack = inspect.stack()
		try:
			base_classes = re.search(r'class.+\((.+)\)\s*\:', stack[2][4][0]).group(1)
		except IndexError:
			raise _function_instead_of_method_error(func)
		meth_cls_name = stack[1][3]

		# handle multiple inheritance
		base_classes = [s.strip() for s in base_classes.split(',')]
		if not base_classes:
			raise ValueError('@override: unable to determine base class') 
	
		# stack[0]=overrides, stack[1]=inside class def'n, stack[2]=outside class def'n
		derived_class_locals = stack[2][0].f_locals
		derived_class_globals = stack[2][0].f_globals
	
		# replace each class name in base_classes with the actual class type
		for i, base_class in enumerate(base_classes):
			if '.' not in base_class:
				if base_class in derived_class_locals:
					base_classes[i] = derived_class_locals[base_class]
				else:
					base_classes[i] = derived_class_globals[base_class]
			else:
				components = base_class.split('.')
				# obj is either a module or a class
				if components[0] in derived_class_locals:
					obj = derived_class_locals[components[0]]
				else:
					obj = derived_class_globals[components[0]]
				for c in components[1:]:
					assert(inspect.ismodule(obj) or inspect.isclass(obj))
					obj = getattr(obj, c)
				base_classes[i] = obj

		found = False
		meth_types = _funcsigtypes(func, True) if has_type_hints(func) else None
		argSpecs = getargspecs(func)
		for cls in base_classes:
			if hasattr(cls, func.__name__):
				found = True
				base_method = getattr(cls, func.__name__)
				_check_override_argspecs(func, argSpecs, meth_cls_name, base_method, cls.__name__)
				if not meth_types is None:
					_check_override_types(func, meth_types, meth_cls_name, base_method, cls.__name__)
		if not found:
			raise _no_base_method_error(func)

	if check_override_at_runtime:
		def checker_ov(*args, **kw):
			argSpecs = getargspecs(func)
			if len(argSpecs.args) > 0 and argSpecs.args[0] == 'self':
				if hasattr(args[0].__class__, func.__name__) and \
						inspect.ismethod(getattr(args[0], func.__name__)):
					ovmro = []
					for mc in args[0].__class__.__mro__[1:]:
						if hasattr(mc, func.__name__):
							ovf = getattr(mc, func.__name__)
							ovmro.append(mc)
					if len(ovmro) == 0:
						raise _no_base_method_error(func)
					# Not yet support overloading
					# Check arg-count compatibility
					for ovcls in ovmro:
						ovf = getattr(ovcls, func.__name__)
						_check_override_argspecs(func, argSpecs, args[0].__class__.__name__, ovf, ovcls.__name__)
					#check arg/res-type compatibility
					meth_types = _funcsigtypes(func, True)
					if has_type_hints(func):
						for ovcls in ovmro:
							ovf = getattr(ovcls, func.__name__)
							_check_override_types(func, meth_types, args[0].__class__.__name__, ovf, ovcls.__name__)
				else:
					raise OverrideError("@override was applied to a non-method: %s.%s.\n"
						% (func.__module__, func.__name__)
						+ "that declares 'self' although not a method.")
			else:
				raise _function_instead_of_method_error(func)
			return func(*args, **kw)
	
		checker_ov.ov_func = func
		checker_ov.__func__ = func
		checker_ov.__name__ = func.__name__ # What sorts of evil might this bring over us?
		checker_ov.__module__ = func.__module__
		if hasattr(func, '__annotations__'):
			checker_ov.__annotations__ = func.__annotations__
		if hasattr(func, '__qualname__'):
			checker_ov.__qualname__ = func.__qualname__
		return checker_ov
	else:
		return func

def _type_str(tp):
	impl = ('__builtin__', 'builtins')
	if inspect.isclass(tp) and not hasattr(typing, tp.__name__):
		if not tp.__module__ in impl:
			module = sys.modules[tp.__module__]
			if not (module.__package__ is None or module.__package__ == ''):
				pck = module.__package__+'.'+tp.__module__+'.'
			else:
				pck = tp.__module__+'.'
		else:
			pck = ''
		return pck+tp.__name__
	else:
		return str(tp).replace("typing.", "")

def _checkfunctype(tp, func, slf, func_class):
	argSig, resSig = _funcsigtypes(func, slf)
	if not issubclass(tp, argSig):
		if slf: #Todo: Clarify if an @override-induced check caused this
			#assert(hasattr(func, "im_class") or type(func) == classmethod)
			# Todo: Python3 misconcepts method as classmethod here, because it doesn't
			# detect it as bound method, because ov_checker or tp_checker obfuscate it
			if hasattr(func, "im_class"):
				raise InputTypeError("%s.%s.%s called with incompatible types:\n"
						% (func.__module__, func.im_class.__name__, func.__name__)
						+ "Expected: %s\nGot:      %s"
						% (_type_str(argSig), _type_str(tp)))
			else:
				raise InputTypeError("classmethod %s.%s.%s called with incompatible types:\n"
					% (func.__module__, func_class.__name__, func.__name__)
					+ "Expected: %s\nGot:      %s"
					% (_type_str(argSig), _type_str(tp)))
		else:
			raise InputTypeError("%s.%s called with incompatible types:\n"
					% (func.__module__, func.__name__)
					+ "Expected: %s\nGot:      %s"
					% (_type_str(argSig), _type_str(tp)))
	return resSig # provide this by-product for potential future use

def _checkfuncresult(resSig, tp, func, slf, func_class):
	if not issubclass(tp, resSig):
		if slf: #Todo: Clarify if an @override-induced check caused this
			if hasattr(func, "im_class"):
				raise ReturnTypeError("%s.%s.%s returned incompatible type:\n"
						% (func.__module__, func.im_class.__name__, func.__name__)
						+ "Expected: %s\nGot:      %s"
						% (_type_str(resSig), _type_str(tp)))
			else:
				raise ReturnTypeError("classmethod %s.%s.%s returned incompatible type:\n"
						% (func.__module__, func_class.__name__, func.__name__)
						+ "Expected: %s\nGot:      %s"
						% (_type_str(resSig), _type_str(tp)))
		else:
			raise ReturnTypeError("%s.%s returned incompatible type:\n"
					% (func.__module__, func.__name__)
					+ "Expected: %s\nGot:      %s"
					% (_type_str(resSig), _type_str(tp)))

def _actualfunc(func):
	if type(func) == classmethod or type(func) == staticmethod:
		return _actualfunc(func.__func__)
	# Todo: maybe rename ov_func and ch_func also to __func__
	if hasattr(func, "ov_func"):
		return _actualfunc(func.ov_func)
	elif hasattr(func, "ch_func"):
		return _actualfunc(func.ch_func)
	else:
		return func

def typechecked_func(func, force = False):
	assert(inspect.isfunction(func) or inspect.ismethod(func) or inspect.ismethoddescriptor(func))
	if not force and is_no_type_check(func):
		return func
	clsm = type(func) == classmethod
	stat = type(func) == staticmethod
	func0 = _actualfunc(func)

	if hasattr(func, "ov_func"):
		checkParents = True
	else:
		checkParents = False

	def checker_tp(*args, **kw):
		# check consistency regarding special case with 'self'-keyword
		slf = False
		argNames = getargspecs(func0).args
		if len(argNames) > 0:
			if clsm:
				if argNames[0] != 'cls':
					print("Warning: classmethod using non-idiomatic argname "+func0.__name__)
				tp = _methargtype(args)
			elif argNames[0] == 'self':
				if hasattr(args[0].__class__, func0.__name__) and \
						inspect.ismethod(getattr(args[0], func0.__name__)):
					tp = _methargtype(args)
					slf = True
				else:
					print("Warning: non-method declaring self "+func0.__name__)
					tp = deep_type(args)
			else:
				tp = deep_type(args)
		else:
			tp = deep_type(args)
			
		if checkParents:
			if not slf:
				raise OverrideError("@override with non-instancemethod not supported: %s.%s.%s.\n"
					% (func0.__module__, args[0].__class__.__name__, func0.__name__))
			toCheck = []
			for cls in args[0].__class__.__mro__:
				if hasattr(cls, func0.__name__):
					ffunc = getattr(cls, func0.__name__)
					if has_type_hints(_actualfunc(ffunc)):
						toCheck.append(_actualfunc(ffunc))
		else:
			toCheck = (func0,)
		resSigs = []
		for ffunc in toCheck:
			resSigs.append(_checkfunctype(tp, ffunc, slf or clsm, args[0].__class__))

		# perform backend-call:
		if clsm or stat:
			res = func.__func__(*args, **kw)
		else:
			res = func(*args, **kw)

		tp = deep_type(res)
		for i in range(len(resSigs)):
			_checkfuncresult(resSigs[i], tp, toCheck[i], slf, args[0].__class__)
		return res

	checker_tp.ch_func = func
	checker_tp.__func__ = func
	checker_tp.__name__ = func0.__name__ # What sorts of evil might this bring over us?
	checker_tp.__module__ = func0.__module__
	if hasattr(func, '__annotations__'):
		checker_tp.__annotations__ = func.__annotations__
	if hasattr(func, '__qualname__'):
		checker_tp.__qualname__ = func.__qualname__
	if clsm:
		return classmethod(checker_tp)
	elif stat:
		return staticmethod(checker_tp)
	else:
		return checker_tp

def typechecked_class(cls, force = False, force_recursive = False):
	assert(inspect.isclass(cls))
	if not force and is_no_type_check(cls):
		return cls
	# To play it safe we avoid to modify the dict while iterating over it,
	# so we previously cache keys.
	# For this we don't use keys() because of Python 3.
	keys = [key for key in cls.__dict__]
	for key in keys:
		obj = cls.__dict__[key]
		if force_recursive or not is_no_type_check(obj):
			if inspect.isfunction(obj) or inspect.ismethod(obj) or inspect.ismethoddescriptor(obj):
				setattr(cls, key, typechecked_func(obj, force_recursive))
			elif inspect.isclass(obj):
				setattr(cls, key, typechecked_class(obj, force_recursive, force_recursive))
	return cls

# Todo: Write tests for this
def typechecked_module(md, force_recursive = False):
	'''
	Intended to typecheck modules that were not annotated with @typechecked without
	modifying their code.
	'''
	assert(inspect.ismodule(md))
	# To play it safe we avoid to modify the dict while iterating over it,
	# so we previously cache keys.
	# For this we don't use keys() because of Python 3.
	keys = [key for key in md.__dict__]
	for key in keys:
		obj = md.__dict__[key]
		if force_recursive or not is_no_type_check(obj):
			if inspect.isfunction(obj) or inspect.ismethod(obj) or inspect.ismethoddescriptor(obj):
				setattr(md, key, typechecked_func(obj, force_recursive))
			elif inspect.isclass(obj):
				setattr(md, key, typechecked_class(obj, force_recursive, force_recursive))

def typechecked(obj):
	if is_no_type_check(obj):
		return obj
	if inspect.isfunction(obj) or inspect.ismethod(obj) or inspect.ismethoddescriptor(obj):
		return typechecked_func(obj)
	if inspect.isclass(obj):
		return typechecked_class(obj)
	return obj

def no_type_check(obj):
	try:
		return typing.no_type_check(obj)
	except(AttributeError):
		not_type_checked.add(obj)
		return obj

def is_no_type_check(obj):
	return (hasattr(obj, "__no_type_check__") and obj.__no_type_check__) or obj in not_type_checked

def get_class_that_defined_method(meth):
	if hasattr(meth, "im_class"):
		return meth.im_class
	elif hasattr(meth, "__qualname__"):
		cls = getattr(inspect.getmodule(meth),
				meth.__qualname__.split('.<locals>', 1)[0].rsplit('.', 1)[0])
		if isinstance(cls, type):
			return cls
	raise ValueError(str(meth)+" is not a method.")

def is_method(func):
	func0 = _actualfunc(func)
	argNames = getargspecs(func0).args
	if len(argNames) > 0:
		if argNames[0] == 'self':
			if inspect.ismethod(func):
				return True
			elif sys.version_info.major >= 3:
				# In Python3 there are no unbound methods, so we count as method,
				# if first arg is called 'self' 
				return True
			else:
				print("Warning (is_method): non-method declaring self "+func0.__name__)
	return False

def is_class(obj):
	if sys.version_info.major >= 3:
		return isinstance(obj, type)
	else:
		return isinstance(obj, (types.TypeType, types.ClassType))

def is_classmethod(meth):
	if not inspect.ismethod(meth):
		return False
	if not is_class(meth.__self__):
		return False
	if not hasattr(meth.__self__, meth.__name__):
		return False
	return meth == getattr(meth.__self__, meth.__name__)

def get_types(func):
	return _get_types(func, is_classmethod(func), is_method(func))

def _get_types(func, clsm, slf):
	func0 = _actualfunc(func)

	# check consistency regarding special case with 'self'-keyword
	if not slf:
		argNames = getargspecs(func0).args
		if len(argNames) > 0:
			if clsm:
				if argNames[0] != 'cls':
					print("Warning: classmethod using non-idiomatic argname "+func0.__name__)
	return _funcsigtypes(func0, slf or clsm)

def get_type_hints(func):
	'''
	Resembles typing.get_type_hints, but is also workable on Python 2.
	'''
	if not has_type_hints(func):
		return {}
	slf = 1 if is_method(func) else 0
	args, res = get_types(func)
	argNames = getargspecs(func).args
	result = {}
	if not args is Any:
		for i in range(slf, len(argNames)):
			result[argNames[i]] = args.__tuple_params__[i-slf]
	result['return'] = res
	return result

# Some exemplary overrides for this modules's global settings:

# Set custom Python3-executable like this:
#python3_5_executable = '/data/workspace/linux/Python-3.5.2/python'

# Set custom directory to store generated stubfiles like this:
# Unlike in tmp-directory mode, these are kept over distinct runs.
#stub_gen_dir = '../py2_stubs'
